Â 
Âcplusplus
Â.com
ÂTUTORIALS REFERENCE ARTICLES FORUM
Â
Âsign up log in
Â[Legacy version]
ÂC++
ÂTutorials
ÂReference
ÂArticles
ÂForum
ÂTutorials
ÂC++ Language
ÂAscii Codes
ÂBoolean Operations
ÂNumerical Bases
ÂC++ Language
ÂIntroduction:
ÂCompilers
ÂBasics of C++:
ÂStructure of a program
ÂVariables and types
ÂConstants
ÂOperators
ÂBasic Input/Output
ÂProgram structure:
ÂStatements and flow control
ÂFunctions
ÂOverloads and templates
ÂName visibility
ÂCompound data types:
ÂArrays
ÂCharacter sequences
ÂPointers
ÂDynamic memory
ÂData structures
ÂOther data types
ÂClasses:
ÂClasses (I)
ÂClasses (II)
ÂSpecial members
ÂFriendship and inheritance
ÂPolymorphism
ÂOther language features:
ÂType conversions
ÂExceptions
ÂPreprocessor directives
ÂStandard library:
ÂInput/output with files
ÂTutorials C++ Language Input/output with files
ÂInput/output with files
ÂC++ provides the following classes to perform output and input of characters to/from files:
Â
Âofstream: Stream class to write on files
Âifstream: Stream class to read from files
Âfstream: Stream class to both read and write from/to files.
Â
ÂThese classes are derived directly or indirectly from the classes istream and ostream. We have already used objects whose types were these classes: cin is an object of class istream and cout is an object of class ostream. Therefore, we have already been using classes that are related to our file streams. And in fact, we can use our file streams the same way we are already used to use cin and cout, with the only difference that we have to associate these streams with physical files. Let's see an example:
Â
Â1
Â2
Â3
Â4
Â5
Â6
Â7
Â8
Â9
Â10
Â11
Â12
Â// basic file operations
Â#include <iostream>
Â#include <fstream>
Âusing namespace std;
Â
Âint main () {
Â  ofstream myfile;
Â  myfile.open ("example.txt");
Â  myfile << "Writing this to a file.\n";
Â  myfile.close();
Â  return 0;
Â}
Â[file example.txt]
ÂWriting this to a file.
Â Edit & run on cpp.sh
Â
Â
ÂThis code creates a file called example.txt and inserts a sentence into it in the same way we are used to do with cout, but using the file stream myfile instead.
Â
ÂBut let's go step by step:
Â
ÂOpen a file
ÂThe first operation generally performed on an object of one of these classes is to associate it to a real file. This procedure is known as to open a file. An open file is represented within a program by a stream (i.e., an object of one of these classes; in the previous example, this was myfile) and any input or output operation performed on this stream object will be applied to the physical file associated to it.
Â
ÂIn order to open a file with a stream object we use its member function open:
Â
Âopen (filename, mode);
Â
ÂWhere filename is a string representing the name of the file to be opened, and mode is an optional parameter with a combination of the following flags:
Â
Âios::in	Open for input operations.
Âios::out	Open for output operations.
Âios::binary	Open in binary mode.
Âios::ate	Set the initial position at the end of the file.
ÂIf this flag is not set, the initial position is the beginning of the file.
Âios::app	All output operations are performed at the end of the file, appending the content to the current content of the file.
Âios::trunc	If the file is opened for output operations and it already existed, its previous content is deleted and replaced by the new one.
Â
ÂAll these flags can be combined using the bitwise operator OR (|). For example, if we want to open the file example.bin in binary mode to add data we could do it by the following call to member function open:
Â
Â1
Â2
Âofstream myfile;
Âmyfile.open ("example.bin", ios::out | ios::app | ios::binary); 
Â
Â
ÂEach of the open member functions of classes ofstream, ifstream and fstream has a default mode that is used if the file is opened without a second argument:
Â
Âclass	default mode parameter
Âofstream	ios::out
Âifstream	ios::in
Âfstream	ios::in | ios::out
Â
ÂFor ifstream and ofstream classes, ios::in and ios::out are automatically and respectively assumed, even if a mode that does not include them is passed as second argument to the open member function (the flags are combined).
Â
ÂFor fstream, the default value is only applied if the function is called without specifying any value for the mode parameter. If the function is called with any value in that parameter the default mode is overridden, not combined.
Â
ÂFile streams opened in binary mode perform input and output operations independently of any format considerations. Non-binary files are known as text files, and some translations may occur due to formatting of some special characters (like newline and carriage return characters).
Â
ÂSince the first task that is performed on a file stream is generally to open a file, these three classes include a constructor that automatically calls the open member function and has the exact same parameters as this member. Therefore, we could also have declared the previous myfile object and conduct the same opening operation in our previous example by writing:
Â
Â 
Âofstream myfile ("example.bin", ios::out | ios::app | ios::binary);
Â
Â
ÂCombining object construction and stream opening in a single statement. Both forms to open a file are valid and equivalent.
Â
ÂTo check if a file stream was successful opening a file, you can do it by calling to member is_open. This member function returns a bool value of true in the case that indeed the stream object is associated with an open file, or false otherwise:
Â
Â 
Âif (myfile.is_open()) { /* ok, proceed with output */ }
Â
Â
ÂClosing a file
ÂWhen we are finished with our input and output operations on a file we shall close it so that the operating system is notified and its resources become available again. For that, we call the stream's member function close. This member function takes flushes the associated buffers and closes the file:
Â
Â 
Âmyfile.close();
Â
Â
ÂOnce this member function is called, the stream object can be re-used to open another file, and the file is available again to be opened by other processes.
Â
ÂIn case that an object is destroyed while still associated with an open file, the destructor automatically calls the member function close.
Â
ÂText files
ÂText file streams are those where the ios::binary flag is not included in their opening mode. These files are designed to store text and thus all values that are input or output from/to them can suffer some formatting transformations, which do not necessarily correspond to their literal binary value.
Â
ÂWriting operations on text files are performed in the same way we operated with cout:
Â
Â1
Â2
Â3
Â4
Â5
Â6
Â7
Â8
Â9
Â10
Â11
Â12
Â13
Â14
Â15
Â16
Â// writing on a text file
Â#include <iostream>
Â#include <fstream>
Âusing namespace std;
Â
Âint main () {
Â  ofstream myfile ("example.txt");
Â  if (myfile.is_open())
Â  {
Â    myfile << "This is a line.\n";
Â    myfile << "This is another line.\n";
Â    myfile.close();
Â  }
Â  else cout << "Unable to open file";
Â  return 0;
Â}
Â[file example.txt]
ÂThis is a line.
ÂThis is another line.
Â Edit & run on cpp.sh
Â
Â
ÂReading from a file can also be performed in the same way that we did with cin:
Â
Â1
Â2
Â3
Â4
Â5
Â6
Â7
Â8
Â9
Â10
Â11
Â12
Â13
Â14
Â15
Â16
Â17
Â18
Â19
Â20
Â21
Â22
Â// reading a text file
Â#include <iostream>
Â#include <fstream>
Â#include <string>
Âusing namespace std;
Â
Âint main () {
Â  string line;
Â  ifstream myfile ("example.txt");
Â  if (myfile.is_open())
Â  {
Â    while ( getline (myfile,line) )
Â    {
Â      cout << line << '\n';
Â    }
Â    myfile.close();
Â  }
Â
Â  else cout << "Unable to open file"; 
Â
Â  return 0;
Â}
ÂThis is a line.
ÂThis is another line.  
Â Edit & run on cpp.sh
Â
Â
ÂThis last example reads a text file and prints out its content on the screen. We have created a while loop that reads the file line by line, using getline. The value returned by getline is a reference to the stream object itself, which when evaluated as a boolean expression (as in this while-loop) is true if the stream is ready for more operations, and false if either the end of the file has been reached or if some other error occurred.
Â
ÂChecking state flags
ÂThe following member functions exist to check for specific states of a stream (all of them return a bool value):
Â
Âbad()
ÂReturns true if a reading or writing operation fails. For example, in the case that we try to write to a file that is not open for writing or if the device where we try to write has no space left.
Âfail()
ÂReturns true in the same cases as bad(), but also in the case that a format error happens, like when an alphabetical character is extracted when we are trying to read an integer number.
Âeof()
ÂReturns true if a file open for reading has reached the end.
Âgood()
ÂIt is the most generic state flag: it returns false in the same cases in which calling any of the previous functions would return true. Note that good and bad are not exact opposites (good checks more state flags at once).
Â
ÂThe member function clear() can be used to reset the state flags.
Â
Âget and put stream positioning
ÂAll i/o streams objects keep internally -at least- one internal position:
Â
Âifstream, like istream, keeps an internal get position with the location of the element to be read in the next input operation.
Â
Âofstream, like ostream, keeps an internal put position with the location where the next element has to be written.
Â
ÂFinally, fstream, keeps both, the get and the put position, like iostream.
Â
ÂThese internal stream positions point to the locations within the stream where the next reading or writing operation is performed. These positions can be observed and modified using the following member functions:
Â
Âtellg() and tellp()
ÂThese two member functions with no parameters return a value of the member type streampos, which is a type representing the current get position (in the case of tellg) or the put position (in the case of tellp).
Â
Âseekg() and seekp()
ÂThese functions allow to change the location of the get and put positions. Both functions are overloaded with two different prototypes. The first form is:
Â
Âseekg ( position );
Âseekp ( position );
Â
ÂUsing this prototype, the stream pointer is changed to the absolute position position (counting from the beginning of the file). The type for this parameter is streampos, which is the same type as returned by functions tellg and tellp.
Â
ÂThe other form for these functions is:
Â
Âseekg ( offset, direction );
Âseekp ( offset, direction );
Â
ÂUsing this prototype, the get or put position is set to an offset value relative to some specific point determined by the parameter direction. offset is of type streamoff. And direction is of type seekdir, which is an enumerated type that determines the point from where offset is counted from, and that can take any of the following values:
Â
Âios::beg	offset counted from the beginning of the stream
Âios::cur	offset counted from the current position
Âios::end	offset counted from the end of the stream
Â
ÂThe following example uses the member functions we have just seen to obtain the size of a file:
Â
Â1
Â2
Â3
Â4
Â5
Â6
Â7
Â8
Â9
Â10
Â11
Â12
Â13
Â14
Â15
Â// obtaining file size
Â#include <iostream>
Â#include <fstream>
Âusing namespace std;
Â
Âint main () {
Â  streampos begin,end;
Â  ifstream myfile ("example.bin", ios::binary);
Â  begin = myfile.tellg();
Â  myfile.seekg (0, ios::end);
Â  end = myfile.tellg();
Â  myfile.close();
Â  cout << "size is: " << (end-begin) << " bytes.\n";
Â  return 0;
Â}
Âsize is: 40 bytes.
Â Edit & run on cpp.sh
Â
Â
ÂNotice the type we have used for variables begin and end:
Â
Â 
Âstreampos size;
Â
Â
Âstreampos is a specific type used for buffer and file positioning and is the type returned by file.tellg(). Values of this type can safely be subtracted from other values of the same type, and can also be converted to an integer type large enough to contain the size of the file.
Â
ÂThese stream positioning functions use two particular types: streampos and streamoff. These types are also defined as member types of the stream class:
Â
ÂType	Member type	Description
Âstreampos	ios::pos_type	Defined as fpos<mbstate_t>.
ÂIt can be converted to/from streamoff and can be added or subtracted values of these types.
Âstreamoff	ios::off_type	It is an alias of one of the fundamental integral types (such as int or long long).
Â
ÂEach of the member types above is an alias of its non-member equivalent (they are the exact same type). It does not matter which one is used. The member types are more generic, because they are the same on all stream objects (even on streams using exotic types of characters), but the non-member types are widely used in existing code for historical reasons.
Â
ÂBinary files
ÂFor binary files, reading and writing data with the extraction and insertion operators (<< and >>) and functions like getline is not efficient, since we do not need to format any data and data is likely not formatted in lines.
Â
ÂFile streams include two member functions specifically designed to read and write binary data sequentially: write and read. The first one (write) is a member function of ostream (inherited by ofstream). And read is a member function of istream (inherited by ifstream). Objects of class fstream have both. Their prototypes are:
Â
Âwrite ( memory_block, size );
Âread ( memory_block, size );
Â
ÂWhere memory_block is of type char* (pointer to char), and represents the address of an array of bytes where the read data elements are stored or from where the data elements to be written are taken. The size parameter is an integer value that specifies the number of characters to be read or written from/to the memory block.
Â
Â1
Â2
Â3
Â4
Â5
Â6
Â7
Â8
Â9
Â10
Â11
Â12
Â13
Â14
Â15
Â16
Â17
Â18
Â19
Â20
Â21
Â22
Â23
Â24
Â25
Â// reading an entire binary file
Â#include <iostream>
Â#include <fstream>
Âusing namespace std;
Â
Âint main () {
Â  streampos size;
Â  char * memblock;
Â
Â  ifstream file ("example.bin", ios::in|ios::binary|ios::ate);
Â  if (file.is_open())
Â  {
Â    size = file.tellg();
Â    memblock = new char [size];
Â    file.seekg (0, ios::beg);
Â    file.read (memblock, size);
Â    file.close();
Â
Â    cout << "the entire file content is in memory";
Â
Â    delete[] memblock;
Â  }
Â  else cout << "Unable to open file";
Â  return 0;
Â}
Âthe entire file content is in memory
Â Edit & run on cpp.sh
Â
Â
ÂIn this example, the entire file is read and stored in a memory block. Let's examine how this is done:
Â
ÂFirst, the file is open with the ios::ate flag, which means that the get pointer will be positioned at the end of the file. This way, when we call to member tellg(), we will directly obtain the size of the file.
Â
ÂOnce we have obtained the size of the file, we request the allocation of a memory block large enough to hold the entire file:
Â
Â 
Âmemblock = new char[size];
Â
Â
ÂRight after that, we proceed to set the get position at the beginning of the file (remember that we opened the file with this pointer at the end), then we read the entire file, and finally close it:
Â
Â1
Â2
Â3
Âfile.seekg (0, ios::beg);
Âfile.read (memblock, size);
Âfile.close();
Â
Â
ÂAt this point we could operate with the data obtained from the file. But our program simply announces that the content of the file is in memory and then finishes.
Â
ÂBuffers and Synchronization
ÂWhen we operate with file streams, these are associated to an internal buffer object of type streambuf. This buffer object may represent a memory block that acts as an intermediary between the stream and the physical file. For example, with an ofstream, each time the member function put (which writes a single character) is called, the character may be inserted in this intermediate buffer instead of being written directly to the physical file with which the stream is associated.
Â
ÂThe operating system may also define other layers of buffering for reading and writing to files.
Â
ÂWhen the buffer is flushed, all the data contained in it is written to the physical medium (if it is an output stream). This process is called synchronization and takes place under any of the following circumstances:
Â
ÂWhen the file is closed: before closing a file, all buffers that have not yet been flushed are synchronized and all pending data is written or read to the physical medium.
ÂWhen the buffer is full: Buffers have a certain size. When the buffer is full it is automatically synchronized.
ÂExplicitly, with manipulators: When certain manipulators are used on streams, an explicit synchronization takes place. These manipulators are: flush and endl.
ÂExplicitly, with member function sync(): Calling the stream's member function sync() causes an immediate synchronization. This function returns an int value equal to -1 if the stream has no associated buffer or in case of failure. Otherwise (if the stream buffer was successfully synchronized) it returns 0.
ÂPreviousPrevious:
ÂPreprocessor directives	Index
ÂIndex	
ÂHome page | Privacy policy
Â cplusplus.com, 2000-2022 - All rights reserved - v3.3.3
ÂSpotted an error? contact us
